<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quickly Report</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Canvas */
        #canvasContainer {
            width: 100%;
            /* ‡πÉ‡∏ä‡πâ‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ Aspect Ratio (Padding Top) 3:2 = (2/3) * 100% = 66.6667% */
            padding-top: 66.6667%; 
            position: relative;
        }

        #imageCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 2px solid #3b82f6; /* ‡∏™‡∏µ‡∏ô‡πâ‡∏≥‡πÄ‡∏á‡∏¥‡∏ô */
            background-color: transparent; 
            border-radius: 0.75rem; /* rounded-xl */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 4px, 6px, 0.05);
            /* ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ Cursor ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÄ‡∏õ‡πá‡∏ô Crosshair ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÇ‡∏´‡∏°‡∏î‡∏ß‡∏≤‡∏î‡∏†‡∏≤‡∏û */
            cursor: crosshair; 
        }

        /* Style ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏∏‡πà‡∏°‡πÇ‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡πÄ‡∏•‡∏∑‡∏≠‡∏Å */
        .mode-btn.active {
            box-shadow: 0 0 0 3px #3b82f6;
            transform: scale(0.98);
        }

        /* Style ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Loading Indicator */
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen p-4 sm:p-8 font-sans">

    <div class="max-w-4xl mx-auto bg-white p-6 sm:p-10 rounded-2xl shadow-2xl">
        <h1 class="text-3xl sm:text-4xl font-extrabold text-gray-800 mb-6 text-center">
            ‚ö° Quickly Report
        </h1>

        <div class="mb-8 p-4 border-b-2 border-blue-100 space-y-4">
            
            <div class="space-y-4 pb-4 border-b border-gray-100">
                <div class="flex flex-col sm:flex-row items-start sm:items-center justify-between space-y-2 sm:space-y-0">
                    <label for="backgroundFileInput" class="text-lg font-medium text-gray-700 whitespace-nowrap">
                        ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á (Template):
                    </label>
                    <input type="file" id="backgroundFileInput" accept="image/*" class="block w-full sm:w-auto text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-yellow-50 file:text-yellow-700 hover:file:bg-yellow-100 cursor-pointer">
                </div>
                
                <div class="flex flex-col sm:flex-row items-start sm:items-center justify-between space-y-2 sm:space-y-0 pt-4">
                    <label for="fileInput" class="text-lg font-medium text-gray-700 whitespace-nowrap">
                        ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏´‡∏•‡∏±‡∏Å (‡πÅ‡∏™‡∏î‡∏á‡∏î‡πâ‡∏≤‡∏ô‡∏´‡∏ô‡πâ‡∏≤):
                    </label>
                    <input type="file" id="fileInput" accept="image/*" multiple class="block w-full sm:w-auto text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 cursor-pointer">
                </div>
            </div>

            <div class="space-y-4 sm:space-y-0 sm:grid sm:grid-cols-2 md:grid-cols-4 sm:gap-4 pt-4">
                <div class="flex flex-col space-y-1">
                    <span class="text-sm font-medium text-gray-700">Area :</span>
                    <input type="text" id="areaInput" placeholder="‡∏£‡∏∞‡∏ö‡∏∏‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà" class="p-3 border border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500 w-full transition duration-150 text-gray-800"/>
                </div>
                <div class="flex flex-col space-y-1">
                    <span class="text-sm font-medium text-gray-700">Title job :</span>
                    <input type="text" id="titleJopInput" placeholder="‡∏õ‡πâ‡∏≠‡∏ô‡∏ä‡∏∑‡πà‡∏≠‡∏á‡∏≤‡∏ô" class="p-3 border border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500 w-full transition duration-150 text-gray-800"/>
                </div>
                <div class="flex flex-col space-y-1">
                    <span class="text-sm font-medium text-gray-700">SAP No. :</span>
                    <input type="text" id="sapNoInput" placeholder="‡∏õ‡πâ‡∏≠‡∏ô‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç SAP" class="p-3 border border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500 w-full transition duration-150 text-gray-800"/>
                </div>
                <div class="flex flex-col space-y-1">
                    <span class="text-sm font-medium text-gray-700">Date :</span>
                    <input type="date" id="dateInput" class="p-3 border border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500 w-full transition duration-150 text-gray-800"/>
                </div>
            </div>
        </div>

        <div class="flex flex-col items-center justify-center">
            <p id="statusMessage" class="text-red-500 mb-4 hidden">‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û</p>
            <div id="canvasContainer" class="w-full">
                <canvas id="imageCanvas"></canvas>
            </div>
            <p class="text-center text-sm text-gray-500 mt-4">‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• ‡πÅ‡∏•‡∏∞‡∏£‡∏π‡∏õ‡∏ß‡∏≤‡∏î‡∏à‡∏∞‡∏õ‡∏£‡∏≤‡∏Å‡∏è‡∏ö‡∏ô Canvas</p>
        </div>
        
        <div class="flex flex-col gap-4 p-4 border-t border-gray-100 mt-8"> 
            
            <input type="text" id="textDrawingInput" placeholder="‡∏û‡∏¥‡∏°‡∏û‡πå‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ß‡∏≤‡∏á‡∏ö‡∏ô‡∏†‡∏≤‡∏û... (‡∏Å‡∏î‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ö‡∏ô Canvas ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ß‡∏≤‡∏á)" 
                   class="p-4 border border-gray-400 rounded-lg shadow-md focus:ring-blue-500 focus:border-blue-500 w-full text-gray-800 hidden text-base" />

            <div class="flex flex-col gap-4">
                <div class="grid grid-cols-2 sm:grid-cols-5 gap-3">
                    <button id="modeRect" class="mode-btn px-4 py-3 rounded-xl font-bold text-base transition duration-150 bg-red-500 text-white hover:bg-red-600 active">‚¨õ ‡∏™‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏µ‡πà‡∏¢‡∏°</button>
                    <button id="modeCircle" class="mode-btn px-4 py-3 rounded-xl font-bold text-base transition duration-150 bg-red-500 text-white hover:bg-red-600">üî¥ ‡∏ß‡∏á‡∏Å‡∏•‡∏°</button>
                    <button id="modeArrow" class="mode-btn px-4 py-3 rounded-xl font-bold text-base transition duration-150 bg-red-500 text-white hover:bg-red-600">‚û°Ô∏è ‡∏•‡∏π‡∏Å‡∏®‡∏£</button>
                    
                    <button id="modeText" class="mode-btn px-4 py-3 rounded-xl font-bold text-base transition duration-150 bg-green-500 text-white hover:bg-green-600">‚úèÔ∏è ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°</button>
                    
                    <button id="btnUndo" class="px-4 py-3 rounded-xl font-bold text-base transition duration-150 bg-amber-500 text-white hover:bg-amber-600">‚Ü©Ô∏è Undo</button>

                    <button id="modeClear" class="px-4 py-3 rounded-xl font-bold text-base transition duration-150 bg-gray-200 text-gray-800 hover:bg-gray-300" onclick="clearShapes()">üóëÔ∏è ‡∏•‡πâ‡∏≤‡∏á‡∏£‡∏π‡∏õ‡∏ß‡∏≤‡∏î</button>
                </div>

                <button 
                    id="saveButton" 
                    class="px-6 py-3 rounded-xl font-bold text-lg transition duration-150 bg-blue-600 text-white hover:bg-blue-700 shadow-xl hover:shadow-2xl w-full disabled:opacity-50 disabled:cursor-not-allowed"
                >
                    <span id="saveButtonContent" class="flex items-center justify-center gap-2">
                        üíæ Save Report (PNG)
                    </span>
                </button>
            </div>
        </div>
        
    </div>

    <script>
        // ‡πÉ‡∏ä‡πâ DOMContentLoaded ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÅ‡∏ô‡πà‡πÉ‡∏à‡∏ß‡πà‡∏≤ Elements ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ñ‡∏π‡∏Å‡πÇ‡∏´‡∏•‡∏î‡πÅ‡∏•‡πâ‡∏ß ‡∏Å‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà script ‡∏à‡∏∞‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
        document.addEventListener('DOMContentLoaded', () => {
            // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏á‡∏ó‡∏µ‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Canvas
            const PADDING_FACTOR = 1; 
            const ASPECT_RATIO = 2 / 3; 
            const BACKGROUND_COLOR = '#ffffff'; // ‡πÉ‡∏ä‡πâ‡∏™‡∏µ‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏™‡∏µ‡∏Ç‡∏≤‡∏ß
            const DRAW_COLOR = '#ff0000'; 
            const DRAW_LINE_WIDTH_FACTOR = 4; 
            // EXPORT_SCALE_FACTOR (2.5) ‡∏Ñ‡∏∑‡∏≠‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏Ç‡∏≠‡∏á‡∏†‡∏≤‡∏û‡∏£‡∏ß‡∏° 2.5 ‡πÄ‡∏ó‡πà‡∏≤
            const EXPORT_SCALE_FACTOR = 2.5; 
            const HEADER_FONT_SIZE = 11;
            const EXTERNAL_H_PADDING_FACTOR = 15;
            // FONT_EXPORT_BOOST_FACTOR (1.5) ‡∏Ñ‡∏∑‡∏≠‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏ô‡∏≤‡∏î Font ‡∏Ç‡∏∂‡πâ‡∏ô‡∏≠‡∏µ‡∏Å 1.5 ‡πÄ‡∏ó‡πà‡∏≤ ‡∏à‡∏≤‡∏Å‡∏Ç‡∏ô‡∏≤‡∏î‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å Scale ‡∏Ç‡∏∂‡πâ‡∏ô‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß
            const FONT_EXPORT_BOOST_FACTOR = 1.5; 
            // ‡∏Ç‡∏ô‡∏≤‡∏î‡∏ü‡∏≠‡∏ô‡∏ï‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏ß‡∏≤‡∏î‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°
            const TEXT_DRAWING_FONT_SIZE = 18;
            
            // Elements
            const backgroundFileInput = document.getElementById('backgroundFileInput');
            const fileInput = document.getElementById('fileInput');
            const areaInput = document.getElementById('areaInput'); 
            const titleJopInput = document.getElementById('titleJopInput'); 
            const sapNoInput = document.getElementById('sapNoInput'); 
            const dateInput = document.getElementById('dateInput');
            const textDrawingInput = document.getElementById('textDrawingInput'); 
            const saveButton = document.getElementById('saveButton'); 
            // (‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°: ‡∏£‡∏±‡∏ö Element ‡∏õ‡∏∏‡πà‡∏° Undo)
            const btnUndo = document.getElementById('btnUndo'); 
            const saveButtonContent = document.getElementById('saveButtonContent'); 
            const canvasContainer = document.getElementById('canvasContainer');
            const canvas = document.getElementById('imageCanvas');
            // ‡∏£‡∏±‡∏ö Context 2D ‡∏Ç‡∏≠‡∏á Canvas
            const ctx = canvas.getContext('2d'); 
            const statusMessage = document.getElementById('statusMessage');

            // Mode Buttons
            const modeRect = document.getElementById('modeRect');
            const modeCircle = document.getElementById('modeCircle');
            const modeArrow = document.getElementById('modeArrow');
            const modeText = document.getElementById('modeText');

            // State Management
            let loadedImages = []; // ‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏´‡∏•‡∏±‡∏Å (Foreground)
            let currentBackgroundImage = null; // ‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á (Background)
            let drawingMode = 'RECT'; 
            let shapes = []; 
            let isDrawing = false;
            let startX = 0;
            let startY = 0;
            let currentShape = null;

            /**
             * Utility: Get Mouse/Touch Position relative to Canvas
             */
            function getCanvasPosition(event) {
                const rect = canvas.getBoundingClientRect();
                let clientX, clientY;

                if (event.touches) {
                    clientX = event.touches[0].clientX;
                    clientY = event.touches[0].clientY;
                } else {
                    clientX = event.clientX;
                    clientY = event.clientY;
                }

                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;

                return {
                    x: (clientX - rect.left) * scaleX,
                    y: (clientY - rect.top) * scaleY
                };
            }

            /**
             * Utility: Draw Arrowhead (Simplified) - Requires targetCtx for flexibility
             */
            function drawArrowhead(targetCtx, fromX, fromY, toX, toY) {
                const headlen = 8 * PADDING_FACTOR; 
                const angle = Math.atan2(toY - fromY, toX - fromX);
                
                targetCtx.beginPath();
                targetCtx.moveTo(toX, toY);
                targetCtx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
                targetCtx.moveTo(toX, toY);
                targetCtx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
                targetCtx.stroke();
            }

            /**
             * ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ß‡∏≤‡∏î‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á (‡πÉ‡∏ä‡πâ‡∏™‡∏µ‡∏û‡∏∑‡πâ‡∏ô‡πÄ‡∏£‡∏µ‡∏¢‡∏ö ‡∏´‡∏£‡∏∑‡∏≠‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î)
             */
            function drawBackground(targetCtx, W, H) {
                // 1. ‡∏ß‡∏≤‡∏î‡∏™‡∏µ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô
                targetCtx.fillStyle = BACKGROUND_COLOR; 
                targetCtx.fillRect(0, 0, W, H);

                // 2. ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏ó‡∏µ‡πà‡πÇ‡∏´‡∏•‡∏î‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‡πÉ‡∏´‡πâ‡∏ô‡∏≥‡∏°‡∏≤‡∏ß‡∏≤‡∏î‡∏ó‡∏±‡∏ö
                if (currentBackgroundImage) {
                    // ‡∏ß‡∏≤‡∏î‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á‡πÉ‡∏´‡πâ‡πÄ‡∏ï‡πá‡∏° Canvas (‡∏¢‡∏∑‡∏î‡∏ï‡∏≤‡∏°‡∏™‡∏±‡∏î‡∏™‡πà‡∏ß‡∏ô 3:2 ‡∏Ç‡∏≠‡∏á Canvas)
                    targetCtx.drawImage(currentBackgroundImage, 0, 0, W, H);
                }
            }
            
            /**
             * ‡πÅ‡∏õ‡∏•‡∏á‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏≤‡∏Å YYYY-MM-DD ‡πÄ‡∏õ‡πá‡∏ô DD/MM/YYYY
             */
            function formatDate(dateStr) {
                if (!dateStr) return 'N/A';
                const parts = dateStr.split('-');
                // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö YYYY-MM-DD ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                if (parts.length === 3 && !isNaN(parseInt(parts[0]))) {
                    return `${parts[2]}/${parts[1]}/${parts[0]}`; 
                }
                return dateStr;
            }


            /**
             * ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ß‡∏≤‡∏î‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° Header ‡∏ó‡∏µ‡πà‡∏à‡∏±‡∏î‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ä‡∏¥‡∏î‡∏ã‡πâ‡∏≤‡∏¢
             */
            function drawHeaderText(targetCtx, W, H) {
                const area = areaInput.value || 'N/A';
                const titleJop = titleJopInput.value || 'N/A';
                const sapNo = sapNoInput.value || 'N/A';
                const dateValue = formatDate(dateInput.value); 

                const PADDING = 10 * PADDING_FACTOR;
                
                // ‡πÉ‡∏ä‡πâ FONT_EXPORT_BOOST_FACTOR ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡∏≥‡∏•‡∏±‡∏á Export 
                const FONT_BOOST = PADDING_FACTOR > 1 ? FONT_EXPORT_BOOST_FACTOR : 1; 

                const FONT_SIZE = HEADER_FONT_SIZE * PADDING_FACTOR * FONT_BOOST;
                const BIG_FONT_SIZE = FONT_SIZE * 1.5; 
                
                const LINE_HEIGHT = FONT_SIZE * 1.5; 
                
                const topPadding = PADDING;
                const leftPadding = PADDING; 
                
                targetCtx.textBaseline = 'top'; 
                targetCtx.fillStyle = '#1f2937'; 
                targetCtx.shadowColor = 'rgba(255, 255, 255, 0.7)'; 
                targetCtx.shadowBlur = 4 * PADDING_FACTOR;
                targetCtx.shadowOffsetX = 1 * PADDING_FACTOR;
                targetCtx.shadowOffsetY = 1 * PADDING_FACTOR;

                const leftX = leftPadding; 
                let currentY = topPadding;
                targetCtx.textAlign = 'left'; 

                // --- 1. Operations Report (‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î‡πÅ‡∏£‡∏Å ‡∏î‡πâ‡∏≤‡∏ô‡∏ã‡πâ‡∏≤‡∏¢ - BIG FONT) ---
                targetCtx.font = `bold ${BIG_FONT_SIZE}px Inter, sans-serif`;
                targetCtx.fillText('Operations report', leftX, currentY); 
                currentY += BIG_FONT_SIZE * 1.1; // ‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏•‡∏á
                
                // --- 2. Area (NORMAL FONT) ---
                targetCtx.font = `bold ${FONT_SIZE}px Inter, sans-serif`;
                targetCtx.fillText(`Area : ${area}`, leftX, currentY); 
                currentY += LINE_HEIGHT; 
                
                // --- 3. Title job (NORMAL FONT) ---
                targetCtx.font = `bold ${FONT_SIZE}px Inter, sans-serif`;
                targetCtx.fillText(`Title job : ${titleJop}`, leftX, currentY); 
                currentY += LINE_HEIGHT; 
                
                // --- 4. SAP No. (NORMAL FONT) ---
                targetCtx.font = `bold ${FONT_SIZE}px Inter, sans-serif`;
                targetCtx.fillText(`SAP : ${sapNo}`, leftX, currentY); 
                currentY += LINE_HEIGHT; // ‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏•‡∏á
                
                // --- 5. Date (‡πÉ‡∏ï‡πâ SAP No. ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ - NORMAL FONT) ---
                targetCtx.font = `bold ${FONT_SIZE}px Inter, sans-serif`;
                targetCtx.fillText(`Date: ${dateValue}`, leftX, currentY); 
                currentY += LINE_HEIGHT; // ‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏•‡∏á

                
                // Clear shadow settings
                targetCtx.shadowColor = 'transparent';
                targetCtx.shadowBlur = 0;
                targetCtx.shadowOffsetX = 0;
                targetCtx.shadowOffsetY = 0;

                // ‡∏™‡πà‡∏á‡∏Å‡∏•‡∏±‡∏ö‡∏Ñ‡πà‡∏≤ Y ‡∏ó‡∏µ‡πà‡∏ï‡πà‡∏≥‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á‡∏ö‡∏•‡πá‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏´‡∏ô‡∏∑‡∏≠‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û + PADDING
                return currentY + PADDING;
            }

            /**
             * ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ß‡∏≤‡∏î‡∏£‡∏π‡∏õ‡∏ß‡∏≤‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
             * @param {CanvasRenderingContext2D} targetCtx context ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ß‡∏≤‡∏î‡∏•‡∏á
             * @param {number} W ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡∏Ç‡∏≠‡∏á Canvas ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô (Visible ‡∏´‡∏£‡∏∑‡∏≠ Export)
             */
            function drawAllShapes(targetCtx, W) {
                const shapesToDraw = [...shapes, ...(currentShape ? [currentShape] : [])];
                
                // ‡πÉ‡∏ä‡πâ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡∏Ç‡∏≠‡∏á Canvas ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô (W) ‡∏´‡∏≤‡∏£‡∏î‡πâ‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡∏Ç‡∏≠‡∏á Canvas ‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏û‡∏¥‡∏Å‡∏±‡∏î (canvas.width) 
                // ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÑ‡∏î‡πâ Scale Factor ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ß‡∏≤‡∏î (‡πÄ‡∏°‡∏∑‡πà‡∏≠ Export ‡∏à‡∏∞‡πÄ‡∏ó‡πà‡∏≤‡∏Å‡∏±‡∏ö 2.5)
                const scale = canvas.width > 0 ? W / canvas.width : 1; 

                // Text specific scaling for drawing shapes
                const FONT_BOOST = PADDING_FACTOR > 1 ? FONT_EXPORT_BOOST_FACTOR : 1; 
                const BASE_FONT_SIZE = TEXT_DRAWING_FONT_SIZE * PADDING_FACTOR * FONT_BOOST;

                shapesToDraw.forEach(shape => {
                    
                    if (shape.type === 'RECT' || shape.type === 'CIRCLE' || shape.type === 'ARROW') {
                        
                        targetCtx.strokeStyle = shape.color;
                        targetCtx.lineWidth = DRAW_LINE_WIDTH_FACTOR * scale; 
                        targetCtx.lineCap = 'round';
                        
                        // Scale coordinates
                        const x1 = shape.x1 * scale;
                        const y1 = shape.y1 * scale;
                        const x2 = shape.x2 * scale;
                        const y2 = shape.y2 * scale;
                        
                        const w = x2 - x1;
                        const h = y2 - y1;

                        if (shape.type === 'RECT') {
                            targetCtx.strokeRect(x1, y1, w, h);
                        } else if (shape.type === 'CIRCLE') {
                            // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏±‡∏®‡∏°‡∏µ‡∏à‡∏≤‡∏Å‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÅ‡∏•‡∏∞‡∏à‡∏∏‡∏î‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î
                            const dx = x2 - x1;
                            const dy = y2 - y1;
                            const radius = Math.sqrt(dx * dx + dy * dy); 
                            
                            targetCtx.beginPath();
                            // ‡∏ß‡∏≤‡∏î‡∏ß‡∏á‡∏Å‡∏•‡∏°‡∏à‡∏≤‡∏Å‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô (x1, y1) ‡∏î‡πâ‡∏ß‡∏¢‡∏£‡∏±‡∏®‡∏°‡∏µ‡∏ó‡∏µ‡πà‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÑ‡∏î‡πâ
                            targetCtx.arc(x1, y1, radius, 0, Math.PI * 2); 
                            targetCtx.stroke();
                        } else if (shape.type === 'ARROW') {
                            targetCtx.beginPath();
                            targetCtx.moveTo(x1, y1);
                            targetCtx.lineTo(x2, y2);
                            targetCtx.stroke();
                            drawArrowhead(targetCtx, x1, y1, x2, y2);
                        }
                    } else if (shape.type === 'TEXT') {
                        // TEXT Drawing Logic
                        targetCtx.fillStyle = shape.color;
                        targetCtx.textAlign = 'left';
                        // ‡πÉ‡∏ä‡πâ 'top' ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏û‡∏¥‡∏Å‡∏±‡∏î y ‡πÄ‡∏õ‡πá‡∏ô‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏Ç‡∏≠‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°
                        targetCtx.textBaseline = 'top'; 
                        targetCtx.font = `bold ${BASE_FONT_SIZE}px Inter, sans-serif`;
                        
                        // Scale coordinates
                        const x = shape.x * scale;
                        const y = shape.y * scale;

                        targetCtx.fillText(shape.text, x, y);
                    }
                });
            }


            /**
             * ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏•‡∏±‡∏Å‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÅ‡∏•‡∏∞‡∏ß‡∏≤‡∏î‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏´‡∏•‡∏±‡∏Å (Foreground) - ‡∏à‡∏±‡∏î‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡πÅ‡∏ô‡∏ß‡∏ô‡∏≠‡∏ô
             */
            function drawForegroundImages(targetCtx, W, imageAreaStartY, imageAreaH, targetHeight) {
                let totalContentWidth = 0;
                const imageDimensions = []; 
                const PADDING = 10 * PADDING_FACTOR; 

                const EXTERNAL_PADDING = EXTERNAL_H_PADDING_FACTOR * PADDING_FACTOR; 

                loadedImages.forEach(img => {
                    const aspectRatio = img.width / img.height;
                    const scaledWidth = targetHeight * aspectRatio;
                    imageDimensions.push({ width: scaledWidth, height: targetHeight });
                    totalContentWidth += scaledWidth;
                });

                const totalPaddingSpace = loadedImages.length > 0 ? loadedImages.length - 1 : 0;

                const availableBlockWidth = W - (2 * EXTERNAL_PADDING); 

                const maxContentWidth = availableBlockWidth - (totalPaddingSpace * PADDING);

                let scaleFactor = 1;

                if (totalContentWidth > maxContentWidth) {
                    scaleFactor = maxContentWidth / totalContentWidth;
                }

                const finalScaledImagesWidth = totalContentWidth * scaleFactor;
                const totalBlockWidth = finalScaledImagesWidth + (totalPaddingSpace * PADDING);

                const leftoverSpaceInAvailableArea = availableBlockWidth - totalBlockWidth; 
                const startX = EXTERNAL_PADDING + (leftoverSpaceInAvailableArea / 2); 

                let currentX = startX; 

                // *** ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏á‡∏≤‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û ***
                targetCtx.shadowColor = 'rgba(0, 0, 0, 0.4)'; // ‡∏™‡∏µ‡πÄ‡∏á‡∏≤‡∏î‡∏≥‡πÇ‡∏õ‡∏£‡πà‡∏á‡πÅ‡∏™‡∏á
                targetCtx.shadowBlur = 10 * PADDING_FACTOR; // ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ü‡∏∏‡πâ‡∏á‡∏Ç‡∏≠‡∏á‡πÄ‡∏á‡∏≤ (‡∏õ‡∏£‡∏±‡∏ö‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥)
                targetCtx.shadowOffsetX = 3 * PADDING_FACTOR; // ‡πÄ‡∏á‡∏≤‡∏î‡πâ‡∏≤‡∏ô‡∏Ç‡∏ß‡∏≤ (‡∏õ‡∏£‡∏±‡∏ö‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥)
                targetCtx.shadowOffsetY = 3 * PADDING_FACTOR; // ‡πÄ‡∏á‡∏≤‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á (‡∏õ‡∏£‡∏±‡∏ö‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥)
                // *** ‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏á‡∏≤‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û ***


                imageDimensions.forEach((dim, index) => {
                    const finalWidth = dim.width * scaleFactor;
                    const finalHeight = dim.height * scaleFactor;
                    
                    const y = imageAreaStartY + ((imageAreaH - finalHeight) / 2); 

                    targetCtx.drawImage(loadedImages[index], currentX, y, finalWidth, finalHeight);
                    
                    currentX += finalWidth + PADDING;
                });
                
                // *** ‡∏•‡πâ‡∏≤‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏á‡∏≤‡∏≠‡∏≠‡∏Å (‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏°‡∏≤‡∏Å) ***
                targetCtx.shadowColor = 'transparent';
                targetCtx.shadowBlur = 0;
                targetCtx.shadowOffsetX = 0;
                targetCtx.shadowOffsetY = 0;
                // *** ‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏•‡πâ‡∏≤‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏á‡∏≤ ***
            }


            /**
             * ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ß‡∏≤‡∏î‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô (‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏´‡∏•‡∏±‡∏Å)
             */
            function drawInitialTextContent(targetCtx, W, H, headerHeight) {
                // ‡∏≠‡∏¢‡πà‡∏≤‡∏•‡∏∑‡∏°‡∏•‡πâ‡∏≤‡∏á Shadow ‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏à‡∏Ñ‡πâ‡∏≤‡∏á‡∏°‡∏≤‡∏à‡∏≤‡∏Å Header Text
                targetCtx.shadowColor = 'transparent';
                targetCtx.shadowBlur = 0;

                // ‡πÉ‡∏ä‡πâ FONT_EXPORT_BOOST_FACTOR ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡∏≥‡∏•‡∏±‡∏á Export (PADDING_FACTOR > 1 ‡∏Ñ‡∏∑‡∏≠ 2.5)
                const FONT_BOOST = PADDING_FACTOR > 1 ? FONT_EXPORT_BOOST_FACTOR : 1;
                const BASE_FONT_SIZE = 24; 
                const INITIAL_FONT_SIZE = BASE_FONT_SIZE * PADDING_FACTOR * FONT_BOOST; 

                targetCtx.fillStyle = '#1f2937'; 
                targetCtx.font = `${INITIAL_FONT_SIZE}px Inter, sans-serif`;
                targetCtx.textAlign = 'center';
                targetCtx.textBaseline = 'middle';
                
                // ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ß‡∏≤‡∏î‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û: ‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà‡πÉ‡∏ï‡πâ Header ‡∏à‡∏ô‡∏ñ‡∏∂‡∏á‡∏Ç‡∏≠‡∏ö Canvas ‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á
                const imageAreaHeight = H - headerHeight; 
                const centerY = headerHeight + (imageAreaHeight / 2);

                if (loadedImages.length === 0) {
                    targetCtx.fillText('‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏´‡∏•‡∏±‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏à‡∏±‡∏î‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡πÉ‡∏ô‡πÅ‡∏ô‡∏ß‡∏ô‡∏≠‡∏ô', W / 2, centerY);
                }
            }


            /**
             * **‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏•‡∏±‡∏Å‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ß‡∏≤‡∏î‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î**
             */
            function redrawContent(targetCtx, W, H) {
                // 1. ‡∏ß‡∏≤‡∏î‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á (‡πÉ‡∏ä‡πâ‡∏™‡∏µ‡∏û‡∏∑‡πâ‡∏ô‡πÄ‡∏£‡∏µ‡∏¢‡∏ö ‡∏´‡∏£‡∏∑‡∏≠‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î)
                drawBackground(targetCtx, W, H); 
                
                // 2. ‡∏ß‡∏≤‡∏î‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° Header ‡πÅ‡∏•‡∏∞‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á‡∏Ç‡∏≠‡∏á Header block
                // H ‡∏ñ‡∏π‡∏Å‡∏™‡πà‡∏á‡∏ú‡πà‡∏≤‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ drawHeaderText ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏à‡∏±‡∏î‡∏ß‡∏≤‡∏á Date ‡πÑ‡∏ß‡πâ‡∏ó‡∏µ‡πà‡∏•‡πà‡∏≤‡∏á‡∏™‡∏∏‡∏î‡πÑ‡∏î‡πâ
                const finalHeaderY = drawHeaderText(targetCtx, W, H); 


                if (loadedImages.length === 0) {
                    // ‡∏ß‡∏≤‡∏î‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏´‡∏•‡∏±‡∏Å
                    drawInitialTextContent(targetCtx, W, H, finalHeaderY); 
                    drawAllShapes(targetCtx, W); 
                    return;
                }
                
                // 3. ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û
                const PADDING = 10 * PADDING_FACTOR; 
                const imageAreaStartY = finalHeaderY;
                
                // ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á‡∏Ç‡∏≠‡∏á‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ß‡∏≤‡∏î‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û ‡∏Ñ‡∏∑‡∏≠‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà‡∏à‡∏∏‡∏î‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á Header ‡∏à‡∏ô‡∏ñ‡∏∂‡∏á‡∏Ç‡∏≠‡∏ö Canvas ‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á
                const imageAreaH = H - imageAreaStartY; 
                // Target height ‡∏Ñ‡∏∑‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á‡∏Ç‡∏≠‡∏á‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏´‡∏•‡∏±‡∏Å ‡πÇ‡∏î‡∏¢‡∏•‡∏ö Padding ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô‡πÅ‡∏•‡∏∞‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á
                const targetHeight = imageAreaH - (2 * PADDING); 

                if (targetHeight <= 0) {
                    console.warn("Not enough space for images after accounting for header.");
                    drawAllShapes(targetCtx, W); 
                    return;
                }
                
                // 4. ‡∏ß‡∏≤‡∏î‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡πÉ‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î (‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏™‡πà‡πÄ‡∏á‡∏≤)
                drawForegroundImages(targetCtx, W, imageAreaStartY, imageAreaH, targetHeight);

                // 5. ‡∏ß‡∏≤‡∏î‡∏£‡∏π‡∏õ‡∏ß‡∏≤‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏±‡∏ö‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û
                drawAllShapes(targetCtx, W); 
            }


            /**
             * ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ß‡∏≤‡∏î Canvas ‡∏ó‡∏µ‡πà‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏ö‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠
             */
            function redrawVisibleCanvas() {
                // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Ç‡∏≠‡∏á Canvas Context ‡∏Å‡πà‡∏≠‡∏ô‡∏ß‡∏≤‡∏î
                if (!ctx) return; 

                const W = canvasContainer.clientWidth;
                const H = W * ASPECT_RATIO;
                
                canvas.width = W;
                canvas.height = H;
                
                window.PADDING_FACTOR = 1;
                
                redrawContent(ctx, W, H);
            }

            
            /**
             * ‡∏•‡πâ‡∏≤‡∏á‡∏£‡∏π‡∏õ‡∏ß‡∏≤‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
             */
            window.clearShapes = function() { // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô Global function ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏à‡∏≤‡∏Å onclick ‡πÑ‡∏î‡πâ
                shapes = [];
                currentShape = null;
                redrawVisibleCanvas();
            }

            /**
             * (‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°: ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Undo ‡∏£‡∏π‡∏õ‡∏ß‡∏≤‡∏î‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î)
             */
            function undoLastShape() {
                if (shapes.length > 0) {
                    shapes.pop(); // ‡∏•‡∏ö element ‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å array
                    redrawVisibleCanvas(); // ‡∏ß‡∏≤‡∏î‡πÉ‡∏´‡∏°‡πà
                }
            }


            /**
             * **‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡∏†‡∏≤‡∏û‡∏î‡πâ‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏™‡∏π‡∏á: ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ô‡πÅ‡∏ó‡πá‡∏ö‡πÉ‡∏´‡∏°‡πà‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏≠‡∏á**
             */
            function exportHighResolution() {
                // 1. ‡∏õ‡∏¥‡∏î‡∏õ‡∏∏‡πà‡∏°‡πÅ‡∏•‡∏∞‡πÅ‡∏™‡∏î‡∏á Loading
                saveButton.disabled = true;
                saveButtonContent.innerHTML = `<div class="loader"></div> Processing...`;
                
                // ‡πÉ‡∏ä‡πâ setTimeout ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏°‡∏µ‡πÄ‡∏ß‡∏•‡∏≤‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï UI (‡πÅ‡∏™‡∏î‡∏á Loading Spinner) ‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏á‡∏≤‡∏ô‡∏´‡∏ô‡∏±‡∏Å
                setTimeout(() => {
                    try {
                        // 2. ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ç‡∏ô‡∏≤‡∏î‡πÉ‡∏´‡∏°‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö High-Resolution
                        const originalW = canvas.width;
                        const exportW = originalW * EXPORT_SCALE_FACTOR;
                        const exportH = exportW * ASPECT_RATIO; 

                        // 3. ‡∏™‡∏£‡πâ‡∏≤‡∏á Canvas ‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß (Off-screen canvas)
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = exportW;
                        tempCanvas.height = exportH;
                        const tempCtx = tempCanvas.getContext('2d');
                        
                        // 4. ‡∏õ‡∏£‡∏±‡∏ö PADDING_FACTOR ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏™‡πÄ‡∏Å‡∏•‡∏Ç‡∏≠‡∏á‡∏†‡∏≤‡∏û‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å
                        window.PADDING_FACTOR = EXPORT_SCALE_FACTOR;

                        // 5. ‡∏ß‡∏≤‡∏î‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏•‡∏á‡∏ö‡∏ô Canvas ‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß‡∏î‡πâ‡∏ß‡∏¢‡∏Ç‡∏ô‡∏≤‡∏î‡πÉ‡∏´‡∏°‡πà
                        redrawContent(tempCtx, exportW, exportH);
                        
                        // 6. ‡πÉ‡∏ä‡πâ toDataURL ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏†‡∏≤‡∏û‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö PNG
                        const dataURL = tempCanvas.toDataURL('image/png');
                        
                        // 7. ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏™‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏°‡∏≤‡∏¢
                        const sanitize = (str) => (str || '').replace(/[^a-z0-9\u0E00-\u0E7F]/gi, '_'); 
                        const area = sanitize(areaInput.value);
                        const titleJop = sanitize(titleJopInput.value);
                        const sapNo = sanitize(sapNoInput.value);
                        const date = formatDate(dateInput.value) || new Date().toISOString().slice(0, 10);
                        const fileName = `Report_${area}_${titleJop}_${sapNo}_${date}.png`;

                        // 8. ‡πÄ‡∏õ‡∏¥‡∏î‡∏†‡∏≤‡∏û‡πÉ‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà (‡∏ß‡∏¥‡∏ò‡∏µ‡∏ó‡∏µ‡πà‡πÄ‡∏™‡∏ñ‡∏µ‡∏¢‡∏£‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£ "‡πÄ‡∏õ‡∏¥‡∏î" ‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û)
                        const newWindow = window.open(dataURL, '_blank');
                        
                        if (newWindow) {
                            // ‡∏ï‡∏±‡πâ‡∏á‡∏ä‡∏∑‡πà‡∏≠‡πÅ‡∏ó‡πá‡∏ö‡πÄ‡∏õ‡πá‡∏ô‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏î‡∏ß‡∏Å‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å
                            newWindow.document.title = fileName; 
                            
                            // Fallback ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏£‡∏ì‡∏µ‡∏ó‡∏µ‡πà‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡πÄ‡∏õ‡∏¥‡∏î‡πÅ‡∏ó‡πá‡∏ö‡πÉ‡∏´‡∏°‡πà‡πÑ‡∏î‡πâ
                        } else {
                            // Fallback: ‡∏ñ‡πâ‡∏≤‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏ö‡∏•‡πá‡∏≠‡∏Å Popup ‡πÉ‡∏´‡πâ‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á 
                            const downloadLink = document.createElement('a');
                            downloadLink.href = dataURL;
                            downloadLink.download = fileName; 
                            document.body.appendChild(downloadLink);
                            downloadLink.click();
                            document.body.removeChild(downloadLink);
                            console.error("Popup was blocked. Initiating direct download.");
                        }

                    } catch (error) {
                        console.error("High-resolution export failed:", error);
                        // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô Console ‡πÅ‡∏ó‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô
                    } finally {
                        // 9. ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤ PADDING_FACTOR ‡πÅ‡∏•‡∏∞ UI
                        window.PADDING_FACTOR = 1; 
                        redrawVisibleCanvas(); 
                        saveButton.disabled = false;
                        saveButtonContent.innerHTML = `üíæ Save Report (PNG)`;
                    }
                }, 100); // ‡∏£‡∏≠ 100ms ‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏° process
            }

            // --- Event Listeners ---

            // 1. File Inputs
            backgroundFileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) {
                    currentBackgroundImage = null;
                    redrawVisibleCanvas();
                    return;
                }
                const img = new Image();
                img.onload = () => {
                    currentBackgroundImage = img;
                    redrawVisibleCanvas();
                };
                img.src = URL.createObjectURL(file);
            });

            fileInput.addEventListener('change', (e) => {
                loadedImages = []; // Clear previous images
                statusMessage.classList.add('hidden');
                const files = Array.from(e.target.files);
                if (files.length === 0) {
                    redrawVisibleCanvas();
                    return;
                }

                let loadedCount = 0;
                files.forEach(file => {
                    const img = new Image();
                    img.onload = () => {
                        loadedImages.push(img);
                        loadedCount++;
                        if (loadedCount === files.length) {
                            // All images loaded
                            redrawVisibleCanvas();
                        }
                    };
                    img.src = URL.createObjectURL(file);
                });
            });

            // 2. Text Inputs (Redraw on change)
            [areaInput, titleJopInput, sapNoInput, dateInput].forEach(input => {
                input.addEventListener('input', redrawVisibleCanvas);
            });

            // 3. Drawing Mode Selection
            function setDrawingMode(mode) {
                drawingMode = mode;
                // Update UI: Remove 'active' from all, add to current
                [modeRect, modeCircle, modeArrow, modeText].forEach(btn => btn.classList.remove('active'));
                if (mode === 'RECT') modeRect.classList.add('active');
                else if (mode === 'CIRCLE') modeCircle.classList.add('active');
                else if (mode === 'ARROW') modeArrow.classList.add('active');
                else if (mode === 'TEXT') modeText.classList.add('active');

                // Show/Hide text input
                if (mode === 'TEXT') {
                    textDrawingInput.classList.remove('hidden');
                    textDrawingInput.focus();
                } else {
                    textDrawingInput.classList.add('hidden');
                }
            }

            modeRect.addEventListener('click', () => setDrawingMode('RECT'));
            modeCircle.addEventListener('click', () => setDrawingMode('CIRCLE'));
            modeArrow.addEventListener('click', () => setDrawingMode('ARROW'));
            modeText.addEventListener('click', () => setDrawingMode('TEXT'));


            // 4. Canvas Drawing Interactions
            function startDrawing(e) {
                isDrawing = true;
                const pos = getCanvasPosition(e);
                startX = pos.x;
                startY = pos.y;

                if (drawingMode === 'TEXT') {
                    const text = textDrawingInput.value.trim();
                    if (text) {
                        shapes.push({ type: 'TEXT', x: startX, y: startY, text: text, color: DRAW_COLOR });
                        textDrawingInput.value = ''; // Clear input
                        redrawVisibleCanvas();
                    }
                    isDrawing = false; // Text is one-click, not drag
                }
            }

            function draw(e) {
                if (!isDrawing) return;
                const pos = getCanvasPosition(e);
                const currentX = pos.x;
                const currentY = pos.y;

                currentShape = {
                    type: drawingMode,
                    x1: startX,
                    y1: startY,
                    x2: currentX,
                    y2: currentY,
                    color: DRAW_COLOR
                };
                redrawVisibleCanvas();
            }

            function stopDrawing(e) {
                if (!isDrawing) return;
                isDrawing = false;
                if (currentShape) {
                    shapes.push(currentShape);
                    currentShape = null;
                }
                redrawVisibleCanvas();
            }

            // Mouse Events
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);

            // Touch Events (for mobile)
            canvas.addEventListener('touchstart', (e) => { e.preventDefault(); startDrawing(e); }, { passive: false });
            canvas.addEventListener('touchmove', (e) => { e.preventDefault(); draw(e); }, { passive: false });
            canvas.addEventListener('touchend', (e) => { e.preventDefault(); stopDrawing(e); }, { passive: false });

            // 5. Save Button & Undo Button
            saveButton.addEventListener('click', exportHighResolution);
            // (‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°: ‡πÄ‡∏û‡∏¥‡πà‡∏° Event Listener ‡πÉ‡∏´‡πâ‡∏õ‡∏∏‡πà‡∏° Undo)
            btnUndo.addEventListener('click', undoLastShape); 

            // 6. Window Resize
            window.addEventListener('resize', redrawVisibleCanvas);

            // Initial Draw
            redrawVisibleCanvas();
        });
    </script>
</body>
</html>